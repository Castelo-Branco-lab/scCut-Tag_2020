#### Read annotation

load_ensembl_annot <- function() {
  library(EnsDb.Mmusculus.v79)
  library(ensembldb)
  
  cat("*** Loading mm10 annotation \n")
  ensdb = EnsDb.Mmusculus.v79

  gene.coords <- ensembldb::genes(ensdb, filter = ~ gene_biotype == "protein_coding")
  lncRNA.coords <- ensembldb::genes(ensdb, filter = ~ gene_biotype == "lincRNA")
  gene.coords <- c(gene.coords,lncRNA.coords)

  seqlevelsStyle(gene.coords) <- 'UCSC'
  genebody.coords <- keepStandardChromosomes(gene.coords, pruning.mode = 'coarse')

  # Flatten the overlapping genes and extend by 2kb upstream of promoters
  genebody.coords.flat <- GenomicRanges::reduce(x = genebody.coords)
  genebodyandpromoter.coords.flat <- Signac::Extend(genebody.coords.flat,upstream = 2000)

  # Retrieve gene names from the original annotation (lost because of flatenning)
  genebodyandpromoter.coords.flat$name<- gene.coords[nearest(genebodyandpromoter.coords.flat,genebody.coords)]$gene_name
  return(genebodyandpromoter.coords.flat)
}


get_path_to_script <- function(){
  args <- commandArgs(trailingOnly=FALSE)
  path <- args[grep(pattern="--file=",x=args)]
  path <- gsub("--file=","",path)
  return(path)
}

createFeatureAssay <- function(seurat_object,features, assay_name) {
  # Look at metadata and if there is none use granges as rownames
  if (length(colnames(features@elementMetadata)) == 0 ) {
    cat("No metadata present for features, using granges to name them \n")
    gene.key                  <- GRangesToString(grange = features)
    names(gene.key)           <- GRangesToString(grange = features)
  } else {
    # If Column name use it as rownames
    if ("name" %in% colnames(features@elementMetadata)){
      gene_names <- "name"
    }
    else{
      # Othrerwise use column #1
      gene_names <- colnames(features@elementMetadata)[1]
      cat(paste("Column name not found in metadata, using column", gene_names,"instead \n"))
    }
    
    gene.key                  <- features@elementMetadata[,gene_names]
    names(gene.key)           <- GRangesToString(grange = features)
  }

  
  gene.activities <- FeatureMatrix(
    fragments = Fragments(seurat_object),
    features = features,
    cells = colnames(seurat_object)
  )
  
  
  rownames(gene.activities) <- gene.key[rownames(gene.activities)]
  gene.activities           <- gene.activities[rownames(gene.activities) != "",]
  
  brain[[assay_name]]       <- CreateAssayObject(counts = gene.activities)
  return(brain)
}

# Calculate metagene score for a vector of genes
metageneScore <- function(seurat_object, genes,assay = "GA") {
  metagene.score <- Matrix::colSums(seurat_object[[assay]]@data[rownames(seurat_object[[assay]]) %in% genes,])
  metagene.score <- metagene.score / Matrix::colSums(seurat_object[[assay]]@counts)
  return(metagene.score)
}

# Calculate metagene score for all clusters in a markers_df generated by Seurat
metageneScoreFromMarkers <- function(seurat_object, markers_df ,assay = "GA") {

  meta.ls <- lapply(unique(markers_df$cluster),function(x) {
    marker.genes <- markers_df[markers_df$cluster==x & markers_df$p_val_adj < 0.05 & markers_df$avg_logFC > 0,"gene"]
    marker.genes <- head(marker.genes,200)
    metascore    <- metageneScore(seurat_object = brain,genes = marker.genes,assay = "GA")
    return(metascore)
  })

  # Collapse list to df
  meta.df           <- do.call(cbind,meta.ls)

  # Rename column names
  colnames(meta.df) <- paste0("metascore_",gsub(" |-",".",unique(markers_df$cluster)))
  return(meta.df)
}


# Export bigwig 

exportBW <- function(object,cluster,fragments,path){
  library(GenomicRanges)
  if(class(object) == "Seurat"){
    cells <- rownames(object@meta.data[object@active.ident == cluster,])
  }
  if(length(cells)==0){return(paste0("No cells found for cluster ",cluster))}
  
  new_read <- GRanges(seqnames = chrom.sizes[,1], 
                      ranges =IRanges(start = as.numeric(chrom.sizes[,2]),
                                      width=1),
                      name = "in_silico_extra_read",
                      score = 0
  )
  
  fragments.x <- fragments$name %in% cells
  fragments.x <- fragments[fragments.x]
  fragments.x <- c(fragments.x,new_read)
  
  
  coverage.x <- coverage(fragments.x)
  
  # normalize by number of reads per sample
  coverage.x <- coverage.x/(length(fragments.x)/1e6)
  
  rtracklayer::export.bw(object = coverage.x,con = path)
}


