#### Read annotation

load_ensembl_annot <- function(version = 'mm10') {
  library(ensembldb)
  
  if (version == 'mm10'){
    cat("*** Loading mm10 annotation of genes \n")
    library(EnsDb.Mmusculus.v79)
    ensdb = EnsDb.Mmusculus.v79
  } else if (version == 'hg38'){
    cat("*** Loading hg38 annotation of genes \n")
    library(EnsDb.Hsapiens.v86)
    ensdb = EnsDb.Hsapiens.v86
  } else {
    cat("*** ERROR: Only mm10 and hg38 supported\n")
    return(NULL)
  }
  

  gene.coords <- ensembldb::genes(ensdb, filter = ~ gene_biotype == "protein_coding")
  lncRNA.coords <- ensembldb::genes(ensdb, filter = ~ gene_biotype == "lincRNA")
  gene.coords <- c(gene.coords,lncRNA.coords)

  seqlevelsStyle(gene.coords) <- 'UCSC'
  genebody.coords <- keepStandardChromosomes(gene.coords, pruning.mode = 'coarse')

  # Flatten the overlapping genes and extend by 2kb upstream of promoters
  genebody.coords.flat <- GenomicRanges::reduce(x = genebody.coords)
  genebodyandpromoter.coords.flat <- Signac::Extend(genebody.coords.flat,upstream = 2000)

  # Retrieve gene names from the original annotation (lost because of flatenning)
  genebodyandpromoter.coords.flat$name<- gene.coords[nearest(genebodyandpromoter.coords.flat,genebody.coords)]$gene_name
  return(genebodyandpromoter.coords.flat)
}

load_ensembl_promoters <- function(version = 'mm10'){
  if (version == 'mm10'){
    cat("*** Loading mm10 annotation of promoters \n")
    library(EnsDb.Mmusculus.v79)
    ensdb = EnsDb.Mmusculus.v79
  } else if (version == 'hg38'){
    cat("*** Loading hg38 annotation of promoters \n")
    library(EnsDb.Hsapiens.v86)
    ensdb = EnsDb.Hsapiens.v86
  } else {
    cat("*** ERROR: Only mm10 and hg38 supported\n")
    return(NULL)
  }
  
  promoter.coords <- promoters(ensdb)
  
  
  promoter.coords <- promoter.coords[promoter.coords$tx_biotype == "protein_coding" | promoter.coords$tx_biotype== "lincRNA"]
  seqlevelsStyle(promoter.coords) <- 'UCSC'
  
  return(promoter.coords)
}


get_path_to_script <- function(){
  args <- commandArgs(trailingOnly=FALSE)
  path <- args[grep(pattern="--file=",x=args)]
  path <- gsub("--file=","",path)
  return(path)
}

createFeatureAssay <- function(seurat_object,features, assay_name) {
  # Look at metadata and if there is none use granges as rownames
  if (length(colnames(features@elementMetadata)) == 0 ) {
    cat("No metadata present for features, using granges to name them \n")
    gene.key                  <- GRangesToString(grange = features)
    names(gene.key)           <- GRangesToString(grange = features)
  } else {
    # If Column name use it as rownames
    if ("name" %in% colnames(features@elementMetadata)){
      gene_names <- "name"
    }
    else{
      # Othrerwise use column #1
      gene_names <- colnames(features@elementMetadata)[1]
      cat(paste("Column name not found in metadata, using column", gene_names,"instead \n"))
    }
    
    gene.key                  <- features@elementMetadata[,gene_names]
    names(gene.key)           <- GRangesToString(grange = features)
  }

  
  gene.activities <- FeatureMatrix(
    fragments = Fragments(seurat_object),
    features = features,
    cells = colnames(seurat_object)
  )
  
  
  rownames(gene.activities) <- gene.key[rownames(gene.activities)]
  gene.activities           <- gene.activities[rownames(gene.activities) != "",]
  
  brain[[assay_name]]       <- CreateAssayObject(counts = gene.activities)
  return(brain)
}

# Calculate metagene score for a vector of genes
metageneScore <- function(seurat_object, genes,assay = "GA") {
  metagene.score <- Matrix::colSums(seurat_object[[assay]]@counts[rownames(seurat_object[[assay]]) %in% genes,])
  metagene.score <- metagene.score / Matrix::colSums(seurat_object[[assay]]@counts)
  return(metagene.score)
}

# Calculate metagene score for all clusters in a markers_df generated by Seurat
metageneScoreFromMarkers <- function(seurat_object, markers_df ,assay = "GA") {

  meta.ls <- lapply(unique(markers_df$cluster),function(x) {
    marker.genes <- markers_df[markers_df$cluster==x & markers_df$p_val_adj < 0.05 & markers_df$avg_logFC > 0,"gene"]
    marker.genes <- head(marker.genes,200)
    metascore    <- metageneScore(seurat_object = seurat_object,genes = marker.genes,assay = assay)
    return(metascore)
  })

  # Collapse list to df
  meta.df           <- do.call(cbind,meta.ls)

  # Rename column names
  colnames(meta.df) <- paste0("metascore_",gsub(" |-",".",unique(markers_df$cluster)))
  return(meta.df)
}


# Export bigwig 

exportBW <- function(object,cluster,fragments,path,chrom.sizes){
  library(GenomicRanges)
  if(class(object) == "Seurat"){
    cells <- rownames(object@meta.data[object@active.ident == cluster,])
  }
  if(length(cells)==0){return(paste0("No cells found for cluster ",cluster))}
  
  new_read <- GRanges(seqnames = chrom.sizes[,1], 
                      ranges =IRanges(start = as.numeric(chrom.sizes[,2]),
                                      width=1),
                      name = "in_silico_extra_read",
                      score = 0
  )
  
  fragments.x <- fragments$name %in% cells
  fragments.x <- fragments[fragments.x]
  fragments.x <- c(fragments.x,new_read)
  
  
  coverage.x <- coverage(fragments.x)
  
  # normalize by number of reads per sample
  coverage.x <- coverage.x/(length(fragments.x)/1e6)
  
  rtracklayer::export.bw(object = coverage.x,con = path)
}

DoHeatmapMB <- function(object, markers,fraction = 0.2,slot = "data",assay, clusterColors){
  
  object <- object[,sample(colnames(object),length(colnames(object)) * fraction)]
  
  row_annotation.df           <- data.frame(markers=markers$cluster)
  rownames(row_annotation.df) <- markers$gene
  col_annotation.df           <- data.frame(clusters=Idents(object))
  col_annotation.df$sample    <- object$sample
  col_annotation.df           <- col_annotation.df[order(col_annotation.df$clusters,col_annotation.df$sample),]
  
  heatmap.mat <- GetAssayData(object = object, slot,assay = assay)
  heatmap.mat <- heatmap.mat[rownames(row_annotation.df),rownames(col_annotation.df)]
  
  print(dim(heatmap.mat))
  
  pheatmap::pheatmap(heatmap.mat,
                     cluster_cols = FALSE, 
                     cluster_rows = FALSE,
                     annotation_row = row_annotation.df,
                     annotation_col = col_annotation.df,
                     color = viridis::viridis(256),
                     show_rownames = FALSE,
                     show_colnames = FALSE,
                     labels_col = "",labels_row = "",
                     annotation_colors = clusterColors)
}




